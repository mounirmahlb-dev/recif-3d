<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artificial Reef Module ‚Äì B√©ni Saf, Algeria</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a3d4f;
        }
        canvas {
            display: block;
        }
        
        /* Overlay Panel */
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 360px;
            background: rgba(5, 30, 45, 0.88);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(100, 180, 200, 0.3);
            border-radius: 12px;
            padding: 18px 22px;
            color: #e0f4f8;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            font-size: 0.85rem;
            line-height: 1.55;
        }
        .overlay h1 {
            font-size: 1.1rem;
            margin-bottom: 14px;
            font-weight: 600;
            color: #7dd3e8;
            border-bottom: 1px solid rgba(100, 180, 200, 0.3);
            padding-bottom: 12px;
            line-height: 1.4;
        }
        .overlay p {
            margin-bottom: 12px;
            opacity: 0.92;
            text-align: justify;
        }
        .overlay p:last-of-type {
            margin-bottom: 0;
        }
        .overlay .hint {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(100, 180, 200, 0.25);
            font-size: 0.78rem;
            color: #a0d8e8;
            opacity: 0.9;
            text-align: center;
            font-style: italic;
        }
        
        /* Loading Indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e0f7fa;
            font-size: 1.1rem;
            z-index: 200;
            text-align: center;
            background: rgba(5, 35, 50, 0.95);
            padding: 32px 44px;
            border-radius: 16px;
            border: 1px solid rgba(100, 180, 200, 0.35);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }
        #loading .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255,255,255,0.15);
            border-top-color: #4dd0e1;
            border-radius: 50%;
            margin: 0 auto 18px auto;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #loading .status {
            font-size: 0.9rem;
            color: #80cbc4;
            margin-top: 8px;
        }
        
        /* Error Message */
        .error-msg {
            color: #ff8a80;
            background: rgba(255, 82, 82, 0.15);
            padding: 16px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        .error-msg strong {
            color: #ff5252;
        }
        
        /* Debug Panel */
        #debug {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 20, 30, 0.85);
            color: #80cbc4;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.75rem;
            z-index: 100;
            max-width: 280px;
            border: 1px solid rgba(100, 180, 200, 0.2);
        }
        #debug .label {
            color: #4dd0e1;
            font-weight: bold;
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 480px) {
            .overlay {
                max-width: calc(100% - 30px);
                left: 15px;
                top: 15px;
                padding: 14px 16px;
                font-size: 0.8rem;
            }
            .overlay h1 {
                font-size: 0.98rem;
            }
            #debug {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Info Overlay -->
    <div class="overlay">
        <h1>ü™∏ Concrete Artificial Reef Module ‚Äì B√©ni Saf Area (Algeria)</h1>
        <p>
            The 3D model represents a concrete artificial reef unit in the form of a
            hollow cube (1 m √ó 1 m √ó 1 m) with circular tunnels passing through the
            structure along the three main axes.
        </p>
        <p>
            The module is intended to be deployed on a sandy seabed at about 20 m depth
            in the coastal area of B√©ni Saf (A√Øn T√©mouchent, Algeria).
        </p>
        <p class="hint">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-click to pan</p>
    </div>
    
    <!-- Loading Indicator -->
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading reef module...</div>
        <div class="status" id="loadStatus">Initializing scene...</div>
    </div>
    
    <!-- Debug Panel -->
    <div id="debug">
        <div><span class="label">Status:</span> <span id="debugStatus">Starting...</span></div>
        <div><span class="label">Model:</span> <span id="debugModel">Not loaded</span></div>
    </div>

    <!-- Three.js with ES Module imports -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const MODEL_PATH = 'module_recif.glb';
        
        // Water/Environment Colors (20m depth Mediterranean)
        const WATER_COLOR = 0x0a4555;
        const FOG_COLOR = 0x0c4a58;
        const FOG_NEAR = 8;
        const FOG_FAR = 55;
        
        // Camera Settings
        const CAMERA_INITIAL_DISTANCE = 8;
        const CAMERA_MIN_DISTANCE = 2;
        const CAMERA_MAX_DISTANCE = 30;
        
        // Module Animation
        const MODULE_FLOAT_HEIGHT = 1.5;
        const MODULE_BOB_AMPLITUDE = 0.06;
        const MODULE_BOB_SPEED = 0.4;
        
        // ============================================================
        // GLOBAL VARIABLES
        // ============================================================
        let scene, camera, renderer, controls;
        let reefModel = null;
        let reefBaseY = 0;
        let particles, causticMesh;
        let fishes = [];
        let seaweedClusters = [];
        
        // Fish Species (Mediterranean coastal)
        const FISH_SPECIES = [
            { name: 'mulet', bodyColor: 0x687878, finColor: 0x485858, size: 0.7 },
            { name: 'sar', bodyColor: 0x6a6050, finColor: 0x504838, size: 0.6 },
            { name: 'merou', bodyColor: 0x484538, finColor: 0x383528, size: 0.9 },
            { name: 'castagnole', bodyColor: 0x3a4850, finColor: 0x283840, size: 0.35 },
            { name: 'loup', bodyColor: 0x586468, finColor: 0x384848, size: 0.8 }
        ];
        
        // ============================================================
        // LOGGING UTILITIES
        // ============================================================
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = {
                'info': 'üìò',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå',
                'loading': '‚è≥'
            }[type] || 'üìò';
            
            console.log(`[${timestamp}] ${prefix} ${message}`);
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('loadStatus');
            const debugStatusEl = document.getElementById('debugStatus');
            if (statusEl) statusEl.textContent = message;
            if (debugStatusEl) debugStatusEl.textContent = message;
        }
        
        function updateModelDebug(message) {
            const el = document.getElementById('debugModel');
            if (el) el.textContent = message;
        }
        
        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            log('Initializing Three.js scene...', 'loading');
            updateStatus('Creating scene...');
            
            try {
                // Create Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(WATER_COLOR);
                scene.fog = new THREE.Fog(FOG_COLOR, FOG_NEAR, FOG_FAR);
                log('Scene created with underwater fog', 'success');
                
                // Create Camera
                camera = new THREE.PerspectiveCamera(
                    50,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    200
                );
                camera.position.set(5, 3, CAMERA_INITIAL_DISTANCE);
                log('Camera initialized', 'success');
                
                // Create Renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 0.9;
                document.body.appendChild(renderer.domElement);
                log('WebGL renderer created', 'success');
                
                // Create OrbitControls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = CAMERA_MIN_DISTANCE;
                controls.maxDistance = CAMERA_MAX_DISTANCE;
                controls.maxPolarAngle = Math.PI * 0.85;
                controls.target.set(0, 0, 0);
                log('OrbitControls initialized (drag to rotate, scroll to zoom)', 'success');
                
                // Setup Scene Elements
                updateStatus('Setting up lighting...');
                setupLighting();
                
                updateStatus('Creating seafloor...');
                createSeafloor();
                
                updateStatus('Adding marine life...');
                createRocks();
                createParticles();
                createFish();
                createSeaweed();
                createCaustics();
                
                // Load GLB Model
                updateStatus('Loading 3D model...');
                loadReefModel();
                
                // Event Listeners
                window.addEventListener('resize', onWindowResize);
                
                log('Scene initialization complete', 'success');
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error');
                console.error(error);
                showError(`Initialization failed: ${error.message}`);
            }
        }
        
        // ============================================================
        // LIGHTING - Realistic 20m Underwater
        // ============================================================
        function setupLighting() {
            // Ambient - blue-green underwater ambiance
            const ambient = new THREE.AmbientLight(0x4a7888, 0.5);
            scene.add(ambient);
            
            // Hemisphere - sky to seafloor gradient
            const hemi = new THREE.HemisphereLight(0x5a9ab0, 0x3a5848, 0.4);
            scene.add(hemi);
            
            // Main sun (filtered through water)
            const sun = new THREE.DirectionalLight(0x88c5d5, 1.5);
            sun.position.set(15, 50, 20);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 1;
            sun.shadow.camera.far = 80;
            sun.shadow.camera.left = -25;
            sun.shadow.camera.right = 25;
            sun.shadow.camera.top = 25;
            sun.shadow.camera.bottom = -25;
            sun.shadow.bias = -0.0001;
            scene.add(sun);
            
            // Fill light (scattered light)
            const fill = new THREE.DirectionalLight(0x5090a0, 0.35);
            fill.position.set(-12, 15, -18);
            scene.add(fill);
            
            // Bounce light from sand
            const bounce = new THREE.DirectionalLight(0xa89068, 0.18);
            bounce.position.set(0, -8, 0);
            scene.add(bounce);
            
            log('Underwater lighting configured', 'success');
        }
        
        // ============================================================
        // SEAFLOOR
        // ============================================================
        function createSeafloor() {
            // Sandy floor with displacement
            const floorGeom = new THREE.PlaneGeometry(150, 150, 80, 80);
            const positions = floorGeom.getAttribute('position');
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                // Natural sand ripples
                const ripple1 = Math.sin(x * 0.2) * Math.cos(y * 0.25) * 0.15;
                const ripple2 = Math.sin(x * 0.5) * Math.cos(y * 0.4) * 0.08;
                const noise = (Math.random() - 0.5) * 0.08;
                positions.setZ(i, ripple1 + ripple2 + noise);
            }
            floorGeom.computeVertexNormals();
            
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0xc8a878,
                roughness: 0.92,
                metalness: 0.02
            });
            
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            log('Seafloor created with sand ripples', 'success');
        }
        
        // ============================================================
        // ROCKS
        // ============================================================
        function createRocks() {
            const rockPositions = [
                { x: 5, z: 4.5, scale: 1.2 },
                { x: -5, z: 5.5, scale: 1.4 },
                { x: -6.5, z: -3.5, scale: 0.9 },
                { x: 6.5, z: -5.5, scale: 1.3 },
                { x: 3.5, z: -6.5, scale: 0.7 },
                { x: -3.5, z: -6, scale: 1.0 },
                { x: 8, z: 1.5, scale: 0.6 },
                { x: -7.5, z: 2.5, scale: 0.85 }
            ];
            
            const rockColors = [0x505a50, 0x5a6a5a, 0x4a5a4a, 0x606a60];
            
            rockPositions.forEach((pos, i) => {
                const geom = new THREE.IcosahedronGeometry(pos.scale, 1);
                const posAttr = geom.getAttribute('position');
                
                for (let j = 0; j < posAttr.count; j++) {
                    const x = posAttr.getX(j);
                    const y = posAttr.getY(j);
                    const z = posAttr.getZ(j);
                    const noise = 0.6 + Math.random() * 0.5;
                    posAttr.setXYZ(j, x * noise, y * noise * 0.5, z * noise);
                }
                geom.computeVertexNormals();
                
                const mat = new THREE.MeshStandardMaterial({
                    color: rockColors[i % rockColors.length],
                    roughness: 0.88,
                    metalness: 0.08
                });
                
                const rock = new THREE.Mesh(geom, mat);
                rock.position.set(pos.x, -1.5, pos.z);
                rock.rotation.set(Math.random() * 0.5, Math.random() * Math.PI, Math.random() * 0.3);
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            });
            
            log('Rocks added to scene', 'success');
        }
        
        // ============================================================
        // MARINE PARTICLES (Plankton/Marine Snow)
        // ============================================================
        function createParticles() {
            const count = 800;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];
            
            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 60;
                positions[i * 3 + 1] = Math.random() * 25 - 3;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
                velocities.push({
                    y: 0.002 + Math.random() * 0.005,
                    xDrift: (Math.random() - 0.5) * 0.001,
                    zDrift: (Math.random() - 0.5) * 0.001,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.userData.velocities = velocities;
            
            const material = new THREE.PointsMaterial({
                color: 0x9acccc,
                size: 0.06,
                transparent: true,
                opacity: 0.5,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            log('Marine particles (plankton) created', 'success');
        }
        
        // ============================================================
        // SEAWEED
        // ============================================================
        function createSeaweed() {
            const seaweedPositions = [
                { x: 1.8, z: 1.8 }, { x: -1.8, z: 1.8 }, { x: 1.8, z: -1.8 }, { x: -1.8, z: -1.8 },
                { x: 2.5, z: 0 }, { x: -2.5, z: 0 }, { x: 0, z: 2.5 }, { x: 0, z: -2.5 },
                { x: 4.5, z: 4 }, { x: -4.5, z: 4.5 }, { x: 5, z: -4.5 }, { x: -5, z: -4 },
                { x: 6, z: 1 }, { x: -6, z: -1.5 }
            ];
            
            const seaweedColors = [0x3a5545, 0x2d4538, 0x456050, 0x3d3828, 0x384538];
            
            seaweedPositions.forEach((pos, idx) => {
                const cluster = new THREE.Group();
                cluster.position.set(pos.x, -2, pos.z);
                
                const bladeCount = 5 + Math.floor(Math.random() * 6);
                
                for (let i = 0; i < bladeCount; i++) {
                    const height = 0.4 + Math.random() * 0.8;
                    const segments = 6;
                    const segmentHeight = height / segments;
                    
                    const color = new THREE.Color(seaweedColors[Math.floor(Math.random() * seaweedColors.length)]);
                    color.offsetHSL(0, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                    
                    const bladeMat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.7,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const bladeGroup = new THREE.Group();
                    let parent = bladeGroup;
                    const segmentsArr = [];
                    
                    for (let s = 0; s < segments; s++) {
                        const taper = 1 - (s / segments) * 0.7;
                        const width = 0.03 * taper;
                        
                        const segGeom = new THREE.PlaneGeometry(width, segmentHeight);
                        const seg = new THREE.Mesh(segGeom, bladeMat);
                        
                        if (s === 0) {
                            bladeGroup.add(seg);
                        } else {
                            parent.add(seg);
                            seg.position.y = segmentHeight;
                        }
                        
                        seg.userData = { 
                            index: s, 
                            baseRotX: (Math.random() - 0.5) * 0.05,
                            baseRotZ: (Math.random() - 0.5) * 0.03
                        };
                        segmentsArr.push(seg);
                        parent = seg;
                    }
                    
                    bladeGroup.position.x = (Math.random() - 0.5) * 0.3;
                    bladeGroup.position.z = (Math.random() - 0.5) * 0.3;
                    bladeGroup.rotation.y = Math.random() * Math.PI * 2;
                    
                    bladeGroup.userData = {
                        segments: segmentsArr,
                        phaseOffset: Math.random() * Math.PI * 2,
                        swaySpeed: 0.2 + Math.random() * 0.2,
                        swayAmount: 0.15 + Math.random() * 0.1
                    };
                    
                    cluster.add(bladeGroup);
                }
                
                scene.add(cluster);
                seaweedClusters.push(cluster);
            });
            
            log('Seaweed clusters created', 'success');
        }
        
        // ============================================================
        // LIGHT CAUSTICS
        // ============================================================
        function createCaustics() {
            const causticGeom = new THREE.PlaneGeometry(100, 100, 25, 25);
            const posAttr = causticGeom.getAttribute('position');
            
            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i);
                const y = posAttr.getY(i);
                const wave = Math.sin(x * 0.3) * Math.cos(y * 0.3) * 0.1;
                posAttr.setZ(i, wave);
            }
            causticGeom.computeVertexNormals();
            
            const causticMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.06,
                blending: THREE.AdditiveBlending
            });
            
            causticMesh = new THREE.Mesh(causticGeom, causticMat);
            causticMesh.rotation.x = -Math.PI / 2;
            causticMesh.position.y = -1.9;
            scene.add(causticMesh);
            
            log('Light caustics effect added', 'success');
        }
        
        // ============================================================
        // FISH
        // ============================================================
        function createFish() {
            for (let i = 0; i < 5; i++) {
                const species = FISH_SPECIES[i % FISH_SPECIES.length];
                const fish = createSingleFish(species);
                
                fish.userData.swimData = {
                    centerX: (Math.random() - 0.5) * 3,
                    centerZ: (Math.random() - 0.5) * 3,
                    radiusX: 4 + Math.random() * 5,
                    radiusZ: 3.5 + Math.random() * 4.5,
                    height: 0.5 + Math.random() * 3,
                    speed: 0.08 + Math.random() * 0.08,
                    phase: Math.random() * Math.PI * 2,
                    tailSpeed: 3 + Math.random() * 2
                };
                
                scene.add(fish);
                fishes.push(fish);
            }
            
            // Small school
            createFishSchool();
            
            log('Fish and school created', 'success');
        }
        
        function createSingleFish(species) {
            const fish = new THREE.Group();
            const s = species.size;
            
            // Body
            const bodyGeom = new THREE.ConeGeometry(s * 0.12, s * 0.7, 8);
            bodyGeom.rotateZ(Math.PI / 2);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: species.bodyColor,
                roughness: 0.5,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.scale.y = 0.6;
            fish.add(body);
            
            // Tail
            const tailGeom = new THREE.ConeGeometry(s * 0.08, s * 0.2, 4);
            tailGeom.rotateZ(-Math.PI / 2);
            const tailMat = new THREE.MeshStandardMaterial({
                color: species.finColor,
                roughness: 0.6,
                side: THREE.DoubleSide
            });
            const tail = new THREE.Mesh(tailGeom, tailMat);
            tail.position.x = -s * 0.4;
            tail.scale.y = 1.8;
            fish.add(tail);
            fish.userData.tail = tail;
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(s * 0.025, 6, 6);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(s * 0.25, s * 0.02, s * 0.05);
            fish.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(s * 0.25, s * 0.02, -s * 0.05);
            fish.add(rightEye);
            
            return fish;
        }
        
        function createFishSchool() {
            const school = new THREE.Group();
            const count = 15 + Math.floor(Math.random() * 8);
            
            for (let i = 0; i < count; i++) {
                const sf = 0.15 + Math.random() * 0.1;
                const bodyGeom = new THREE.ConeGeometry(sf * 0.06, sf * 0.25, 5);
                bodyGeom.rotateZ(Math.PI / 2);
                
                const color = new THREE.Color(0x3a4850);
                color.offsetHSL(0, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.08);
                
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.55 });
                const smallFish = new THREE.Mesh(bodyGeom, mat);
                
                const radius = 0.3 + Math.random() * 1;
                const theta = Math.random() * Math.PI * 2;
                smallFish.position.set(
                    radius * Math.cos(theta),
                    (Math.random() - 0.5) * 0.5,
                    radius * Math.sin(theta)
                );
                
                smallFish.userData.offset = {
                    x: smallFish.position.x,
                    y: smallFish.position.y,
                    z: smallFish.position.z,
                    phase: Math.random() * Math.PI * 2
                };
                
                school.add(smallFish);
            }
            
            school.userData.isSchool = true;
            school.userData.swimData = {
                centerX: 2,
                centerZ: -1,
                radiusX: 6,
                radiusZ: 5,
                height: 2,
                speed: 0.12,
                phase: Math.random() * Math.PI * 2
            };
            
            scene.add(school);
            fishes.push(school);
        }
        
        // ============================================================
        // LOAD GLB MODEL
        // ============================================================
        function loadReefModel() {
            log(`Loading model from: ${MODEL_PATH}`, 'loading');
            updateModelDebug('Loading...');
            
            const loader = new GLTFLoader();
            
            loader.load(
                MODEL_PATH,
                // Success callback
                (gltf) => {
                    log('GLB file loaded successfully!', 'success');
                    
                    const model = gltf.scene;
                    
                    // Calculate bounds
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    log(`Model dimensions: W=${size.x.toFixed(2)}m, H=${size.y.toFixed(2)}m, D=${size.z.toFixed(2)}m`, 'info');
                    
                    // Center horizontally
                    model.position.x = -center.x;
                    model.position.z = -center.z;
                    
                    // Position floating above seafloor
                    const seafloorY = -2;
                    reefBaseY = seafloorY + MODULE_FLOAT_HEIGHT + (size.y / 2);
                    model.position.y = -center.y + reefBaseY;
                    
                    // Apply materials and shadows
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Enhance materials for underwater look
                            if (child.material) {
                                child.material.envMapIntensity = 0.4;
                                // Slightly desaturate for underwater color absorption
                                if (child.material.color) {
                                    const c = child.material.color;
                                    c.offsetHSL(0, -0.1, 0);
                                }
                            }
                        }
                    });
                    
                    reefModel = model;
                    scene.add(model);
                    
                    // Update controls target to model center
                    controls.target.set(0, reefBaseY - size.y/2, 0);
                    controls.update();
                    
                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';
                    
                    updateModelDebug(`Loaded (${size.x.toFixed(1)}√ó${size.y.toFixed(1)}√ó${size.z.toFixed(1)}m)`);
                    log('Model added to scene and visible!', 'success');
                    
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('‚úÖ REEF MODULE LOADED SUCCESSFULLY');
                    console.log(`üìê Dimensions: ${size.x.toFixed(2)} √ó ${size.y.toFixed(2)} √ó ${size.z.toFixed(2)} meters`);
                    console.log(`üìç Position: Floating ${MODULE_FLOAT_HEIGHT}m above seafloor`);
                    console.log('üñ±Ô∏è Controls: Drag to rotate, scroll to zoom, right-click to pan');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                },
                // Progress callback
                (xhr) => {
                    if (xhr.lengthComputable) {
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        updateStatus(`Loading model... ${percent}%`);
                        updateModelDebug(`${percent}%`);
                        log(`Loading progress: ${percent}%`, 'loading');
                    } else {
                        updateStatus(`Loading model... (${(xhr.loaded / 1024).toFixed(0)} KB)`);
                    }
                },
                // Error callback
                (error) => {
                    log(`Failed to load model: ${error.message || error}`, 'error');
                    console.error('Full error:', error);
                    
                    updateModelDebug('FAILED');
                    showError(`
                        <strong>Could not load: ${MODEL_PATH}</strong><br><br>
                        Please ensure:<br>
                        ‚Ä¢ The file <code>module_recif.glb</code> is in the same folder as this HTML file<br>
                        ‚Ä¢ You're running this from a web server (not file://)<br>
                        ‚Ä¢ The GLB file is not corrupted<br><br>
                        <small>Check browser console (F12) for details.</small>
                    `);
                    
                    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.error('‚ùå MODEL LOADING FAILED');
                    console.error('File path:', MODEL_PATH);
                    console.error('Error:', error);
                    console.error('');
                    console.error('TROUBLESHOOTING:');
                    console.error('1. Make sure "module_recif.glb" is in the same directory');
                    console.error('2. If using file://, start a local server instead:');
                    console.error('   - Python: python -m http.server 8000');
                    console.error('   - Node: npx serve');
                    console.error('   - VS Code: Use "Live Server" extension');
                    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                }
            );
        }
        
        function showError(message) {
            const loading = document.getElementById('loading');
            loading.innerHTML = `<div class="error-msg">${message}</div>`;
        }
        
        // ============================================================
        // ANIMATION LOOP
        // ============================================================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            controls.update();
            animateParticles(time);
            animateFish(time);
            animateSeaweed(time);
            animateCaustics(time);
            animateModule(time);
            
            renderer.render(scene, camera);
        }
        
        function animateParticles(time) {
            if (!particles) return;
            
            const positions = particles.geometry.getAttribute('position');
            const velocities = particles.geometry.userData.velocities;
            
            for (let i = 0; i < positions.count; i++) {
                const vel = velocities[i];
                let y = positions.getY(i) + vel.y;
                let x = positions.getX(i) + vel.xDrift + Math.sin(time * 0.3 + vel.phase) * 0.002;
                let z = positions.getZ(i) + vel.zDrift + Math.cos(time * 0.3 + vel.phase) * 0.002;
                
                if (y > 20) {
                    y = -3;
                    x = (Math.random() - 0.5) * 60;
                    z = (Math.random() - 0.5) * 60;
                }
                
                positions.setXYZ(i, x, y, z);
            }
            positions.needsUpdate = true;
        }
        
        function animateFish(time) {
            fishes.forEach((fish) => {
                const data = fish.userData.swimData;
                if (!data) return;
                
                const t = time * data.speed + data.phase;
                
                const x = data.centerX + Math.cos(t) * data.radiusX;
                const z = data.centerZ + Math.sin(t) * data.radiusZ;
                const y = data.height + Math.sin(t * 0.6) * 0.4;
                
                fish.position.set(x, y, z);
                
                // Face direction of travel
                const nextT = t + 0.02;
                const nextX = data.centerX + Math.cos(nextT) * data.radiusX;
                const nextZ = data.centerZ + Math.sin(nextT) * data.radiusZ;
                fish.rotation.y = Math.atan2(nextX - x, nextZ - z);
                
                // Tail animation
                if (fish.userData.tail) {
                    fish.userData.tail.rotation.y = Math.sin(time * (data.tailSpeed || 4)) * 0.3;
                }
                
                // School animation
                if (fish.userData.isSchool) {
                    fish.children.forEach((child) => {
                        if (child.userData.offset) {
                            const off = child.userData.offset;
                            child.position.x = off.x + Math.sin(time * 1.5 + off.phase) * 0.1;
                            child.position.y = off.y + Math.sin(time * 1.0 + off.phase) * 0.05;
                            child.position.z = off.z + Math.cos(time * 1.3 + off.phase) * 0.08;
                            child.rotation.z = Math.sin(time * 4 + off.phase) * 0.08;
                        }
                    });
                }
            });
        }
        
        function animateSeaweed(time) {
            const currentDir = Math.sin(time * 0.08) * 0.3;
            
            seaweedClusters.forEach((cluster) => {
                cluster.children.forEach((blade) => {
                    if (!blade.userData || !blade.userData.segments) return;
                    
                    const { segments, phaseOffset, swaySpeed, swayAmount } = blade.userData;
                    
                    segments.forEach((seg, i) => {
                        const influence = Math.pow((i + 1) / segments.length, 1.3);
                        const sway = Math.sin(time * swaySpeed + phaseOffset + i * 0.2) * swayAmount * influence;
                        
                        seg.rotation.z = (seg.userData.baseRotZ || 0) + sway + currentDir * influence * 0.1;
                        seg.rotation.x = (seg.userData.baseRotX || 0) + Math.cos(time * swaySpeed * 0.5 + phaseOffset) * swayAmount * 0.3 * influence;
                    });
                });
            });
        }
        
        function animateCaustics(time) {
            if (!causticMesh) return;
            causticMesh.material.opacity = 0.04 + Math.sin(time * 1.2) * 0.02;
            causticMesh.position.x = Math.sin(time * 0.15) * 0.8;
            causticMesh.position.z = Math.cos(time * 0.12) * 0.6;
        }
        
        function animateModule(time) {
            if (!reefModel) return;
            
            // Gentle bobbing
            const bob = Math.sin(time * MODULE_BOB_SPEED) * MODULE_BOB_AMPLITUDE;
            const secondaryBob = Math.sin(time * MODULE_BOB_SPEED * 0.6 + 1.5) * MODULE_BOB_AMPLITUDE * 0.3;
            
            reefModel.position.y = reefBaseY + bob + secondaryBob;
            
            // Very subtle sway
            reefModel.rotation.x = Math.sin(time * 0.25) * 0.012;
            reefModel.rotation.z = Math.cos(time * 0.2 + 0.5) * 0.008;
        }
        
        // ============================================================
        // WINDOW RESIZE
        // ============================================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ============================================================
        // START APPLICATION
        // ============================================================
        log('Application starting...', 'info');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('ü™∏ ARTIFICIAL REEF MODULE VIEWER');
        console.log('üìç B√©ni Saf, Algeria - Marine Biology Project');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        init();
        animate();
        
    </script>
</body>
</html>
